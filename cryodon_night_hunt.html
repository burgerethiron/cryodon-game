<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cryodon Night Hunt (UG)</title>
<style>
html, body { margin:0; height:100%; background:#05070a; color:#dce7ff; font-family:system-ui,Segoe UI,Roboto,Arial; overflow:hidden; }
#ui {
position:fixed; inset:0; pointer-events:none;
display:flex; flex-direction:column; justify-content:space-between;
}
#topbar{
pointer-events:none;
display:flex; justify-content:space-between; align-items:flex-start;
padding:12px 12px 0 12px;
}
.panel{
pointer-events:none;
background:rgba(0,0,0,0.35);
border:1px solid rgba(255,255,255,0.12);
backdrop-filter: blur(6px);
border-radius:14px;
padding:10px 12px;
box-shadow:0 10px 30px rgba(0,0,0,0.55);
}
.small { font-size:12px; opacity:0.9; }
.big { font-size:18px; font-weight:800; letter-spacing:0.4px; }
.row { display:flex; gap:10px; align-items:center; justify-content:space-between; }
.bar {
width:220px; height:10px; border-radius:999px; overflow:hidden;
background:rgba(255,255,255,0.08);
border:1px solid rgba(255,255,255,0.10);
}
.fill { height:100%; width:50%; background:rgba(160,200,255,0.95); }
.fill.red { background:rgba(255,90,90,0.95); }
#centerHint{
position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
text-align:center;
pointer-events:none;
text-shadow:0 2px 10px rgba(0,0,0,0.8);
}
#crosshair{
position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
width:14px; height:14px; opacity:0.8; pointer-events:none;
}
#crosshair:before, #crosshair:after{
content:""; position:absolute; background:rgba(230,245,255,0.9);
}
#crosshair:before{ left:6px; top:0; width:2px; height:14px; }
#crosshair:after{ left:0; top:6px; width:14px; height:2px; }

#bottom{
display:flex; justify-content:space-between; gap:12px;
padding:0 12px 12px 12px;
pointer-events:none;
}
#msg{
max-width:min(700px, 92vw);
line-height:1.35;
}
#overlay {
position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
background: radial-gradient(1200px 700px at 50% 40%, rgba(20,30,55,0.40), rgba(0,0,0,0.88));
z-index:10;
}
#overlay .card{
width:min(860px, 92vw);
background:rgba(0,0,0,0.45);
border:1px solid rgba(255,255,255,0.12);
border-radius:18px;
padding:18px 18px 14px 18px;
box-shadow:0 18px 60px rgba(0,0,0,0.75);
backdrop-filter: blur(8px);
}
button{
pointer-events:auto;
cursor:pointer;
border-radius:12px;
border:1px solid rgba(255,255,255,0.18);
background:rgba(255,255,255,0.10);
color:#eaf2ff;
font-weight:700;
padding:10px 12px;
}
button:hover{ background:rgba(255,255,255,0.16); }
kbd{
font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
font-size:12px;
border:1px solid rgba(255,255,255,0.18);
background:rgba(255,255,255,0.08);
padding:2px 6px;
border-radius:7px;
}
a { color:#bfe0ff; }
canvas{ display:block; width:100vw; height:100vh; image-rendering: pixelated; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
<div id="topbar">
<div class="panel">
<div class="big">Cryodon Night Hunt</div>
<div class="small">Collect <b>3 ice shards</b> (Cryodon teeth) and escape via the <b>cave</b>.</div>
<div class="small">Enemies: <b>Raptoe pack</b>, <b>Razorclaw</b>, <b>Spikejaw</b>. (They spawn far.)</div>
</div>

<div class="panel">
<div class="row small" style="gap:14px;">
<div>
<div>Stamina</div>
<div class="bar"><div id="stam" class="fill"></div></div>
</div>
<div>
<div>Health</div>
<div class="bar"><div id="hp" class="fill red"></div></div>
</div>
</div>
<div class="row small" style="margin-top:8px; gap:10px;">
<div>Shards: <b><span id="shards">0</span>/3</b></div>
<div>Biome: <b><span id="biome">Forest</span></b></div>
</div>
</div>
</div>

<div id="centerHint" class="small" style="opacity:0.0;">
<div style="font-size:14px; font-weight:800;">ICE SHARD FOUND</div>
<div>Keep moving. The night is listening.</div>
</div>

<div id="bottom">
<div id="msg" class="panel small">
<div><b>Controls:</b> <kbd>WASD</kbd> move · <kbd>Shift</kbd> sprint · <kbd>Mouse</kbd> look · <kbd>E</kbd> interact (at cave)</div>
<div>Tip: Stay under the canopy. The ice biome is colder… and louder.</div>
</div>
<div class="panel small" style="min-width:220px;">
<div><b>Status</b></div>
<div id="statusLine">Click “Start” to enable audio + mouse look.</div>
</div>
</div>
</div>

<div id="crosshair"></div>

<div id="overlay">
<div class="card">
<div class="big">Nightfall. Three teeth. One way out.</div>
<div class="small" style="margin-top:8px; line-height:1.45;">
• First-person raycast world with a <b>giant oak canopy</b> forest and an <b>ice biome</b>.<br>
• Pick up <b>3 Cryodon teeth</b> (ice shards) then find the <b>cave</b> and press <kbd>E</kbd> to escape.<br>
• Enemies use your UG art as <b>sprite “models”</b>. If you don’t add the images, it will use placeholders.
<div style="margin-top:10px;">
Put these files here:
<div class="small"><code>assets/cryodon.png</code> · <code>assets/raptoe.png</code> · <code>assets/razorclaw.png</code> · <code>assets/spikejaw.png</code></div>
</div>
</div>
<div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
<button id="startBtn">Start</button>
<button id="howBtn">Show setup help</button>
</div>
<div id="help" class="small" style="margin-top:10px; opacity:0.92; display:none;">
If it opens as code text: you saved it as <code>.txt</code>. Rename to <code>index.html</code>.<br>
If mouse look doesn’t work: click Start, then click the game, then press <kbd>Esc</kbd> to exit pointer lock.
</div>
</div>
</div>

<script>
(() => {
// ===== Canvas =====
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){
const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
canvas.width = Math.floor(innerWidth * dpr);
canvas.height = Math.floor(innerHeight * dpr);
ctx.imageSmoothingEnabled = false;
}
window.addEventListener("resize", resize);
resize();

// ===== UI =====
const elStam = document.getElementById("stam");
const elHp = document.getElementById("hp");
const elShards = document.getElementById("shards");
const elBiome = document.getElementById("biome");
const elStatus = document.getElementById("statusLine");
const elHint = document.getElementById("centerHint");
const overlay = document.getElementById("overlay");
const startBtn = document.getElementById("startBtn");
const howBtn = document.getElementById("howBtn");
const help = document.getElementById("help");
howBtn.onclick = () => help.style.display = (help.style.display === "none" ? "block" : "none");

// ===== Audio (procedural) =====
let AC = null, master = null;
function audioInit(){
AC = new (window.AudioContext || window.webkitAudioContext)();
master = AC.createGain();
master.gain.value = 0.6;
master.connect(AC.destination);
}
function beep(freq, dur, type="sine", gain=0.08){
if(!AC) return;
const o = AC.createOscillator();
const g = AC.createGain();
o.type = type;
o.frequency.value = freq;
g.gain.value = 0.0001;
o.connect(g); g.connect(master);
const t = AC.currentTime;
g.gain.setValueAtTime(0.0001, t);
g.gain.linearRampToValueAtTime(gain, t + 0.01);
g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
o.start(t); o.stop(t + dur + 0.02);
}
function noiseBurst(dur=0.18, gain=0.10){
if(!AC) return;
const len = Math.floor(AC.sampleRate * dur);
const buf = AC.createBuffer(1, len, AC.sampleRate);
const data = buf.getChannelData(0);
for(let i=0;i<len;i++){
data[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 2);
}
const src = AC.createBufferSource(); src.buffer = buf;
const g = AC.createGain(); g.gain.value = gain;
src.connect(g); g.connect(master);
src.start();
}
function footstep(){
// soft thud + faint crunch if in ice biome
noiseBurst(0.06, 0.04);
beep(80, 0.05, "sine", 0.03);
if (player.biome === "ice") noiseBurst(0.08, 0.06);
}
function screech(kind){
// kind: "raptoe" | "razor" | "spike"
if(kind==="raptoe"){ beep(520, 0.10, "square", 0.05); beep(760, 0.08, "square", 0.04); noiseBurst(0.08, 0.05); }
if(kind==="razor"){ beep(220, 0.18, "sawtooth", 0.07); noiseBurst(0.12, 0.06); }
if(kind==="spike"){ beep(140, 0.22, "sawtooth", 0.08); beep(90, 0.26, "square", 0.05); noiseBurst(0.14, 0.06); }
}
function pickupSound(){ beep(880, 0.08, "sine", 0.06); beep(1320, 0.06, "sine", 0.05); }
function hurtSound(){ beep(120, 0.10, "square", 0.07); noiseBurst(0.12, 0.08); }
function winSound(){ beep(660, 0.10, "sine", 0.06); beep(990, 0.12, "sine", 0.06); beep(1320, 0.14, "sine", 0.06); }
function loseSound(){ beep(220, 0.25, "sawtooth", 0.08); beep(140, 0.30, "square", 0.07); }

// ===== Input / pointer lock =====
const keys = new Set();
window.addEventListener("keydown", (e) => {
keys.add(e.key.toLowerCase());
if(e.key === "Escape"){ /* handled by browser */ }
});
window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

let pointerLocked = false;
canvas.addEventListener("click", () => {
if(!pointerLocked) canvas.requestPointerLock?.();
});
document.addEventListener("pointerlockchange", () => {
pointerLocked = (document.pointerLockElement === canvas);
});

let mouseDX = 0;
document.addEventListener("mousemove", (e) => {
if(pointerLocked){ mouseDX += e.movementX || 0; }
});

// ===== World (raycast grid) =====
// 0 empty, 1 forest wall (trees/rocks), 2 ice wall, 3 cave exit marker (open tile but special)
const W = 64, H = 64;
const map = new Uint8Array(W*H);

function idx(x,y){ return y*W + x; }
function inb(x,y){ return x>=0 && y>=0 && x<W && y<H; }

// deterministic-ish RNG
let seed = 1337;
function rand(){
seed = (seed * 1664525 + 1013904223) >>> 0;
return seed / 4294967296;
}

// Build: giant canopy forest + ice biome chunk on east side.
function genWorld(){
map.fill(0);

// Borders as walls
for(let x=0;x<W;x++){ map[idx(x,0)] = 1; map[idx(x,H-1)] = 1; }
for(let y=0;y<H;y++){ map[idx(0,y)] = 1; map[idx(W-1,y)] = 1; }

// Ice biome rectangle on the east side
const iceX0 = 42, iceX1 = 62, iceY0 = 10, iceY1 = 54;

// Scatter forest walls: thicker “oak forest” density
for(let y=1;y<H-1;y++){
for(let x=1;x<W-1;x++){
const inIce = (x>=iceX0 && x<=iceX1 && y>=iceY0 && y<=iceY1);
const edgeIce = inIce && (x===iceX0||x===iceX1||y===iceY0||y===iceY1);

if(edgeIce){
map[idx(x,y)] = 2; // icy ridge border
continue;
}

if(inIce){
// sparse ice pillars
if(rand() < 0.07) map[idx(x,y)] = 2;
} else {
// dense forest trunks/rocks
let p = 0.16; // base density
// make central forest even denser (canopy feel)
const dx = x - 20, dy = y - 32;
const d = Math.sqrt(dx*dx + dy*dy);
if(d < 18) p += 0.08;
if(d < 10) p += 0.06;
if(rand() < p) map[idx(x,y)] = 1;
}
}
}

// Carve out a few clearings and trails so it's playable
function carveLine(x0,y0,x1,y1,r=1){
const steps = Math.max(Math.abs(x1-x0), Math.abs(y1-y0));
for(let i=0;i<=steps;i++){
const t = i/steps;
const x = Math.round(x0 + (x1-x0)*t);
const y = Math.round(y0 + (y1-y0)*t);
for(let oy=-r; oy<=r; oy++){
for(let ox=-r; ox<=r; ox++){
if(inb(x+ox,y+oy)) map[idx(x+ox,y+oy)] = 0;
}
}
}
}
carveLine(6, 56, 30, 40, 2);
carveLine(30, 40, 40, 28, 2);
carveLine(40, 28, 50, 30, 2); // into ice
carveLine(8, 20, 25, 18, 2);

// Cave exit near north-west-ish
const cave = { x: 8, y: 8 };
// clear cave area
for(let y=cave.y-2;y<=cave.y+2;y++){
for(let x=cave.x-2;x<=cave.x+2;x++){
if(inb(x,y)) map[idx(x,y)] = 0;
}
}
map[idx(cave.x, cave.y)] = 3;

return { cave, iceRect:{x0:iceX0,x1:iceX1,y0:iceY0,y1:iceY1} };
}

const world = genWorld();

// ===== Player =====
const player = {
x: 10.5, y: 56.5,
a: -Math.PI/2, // facing north-ish
fov: Math.PI/3,
hp: 100,
stam: 100,
shards: 0,
alive: true,
won: false,
biome: "forest",
};

// ===== Sprites: use your UG sheets as “models” =====
// We'll crop a representative frame automatically (top-left-ish creature art area).
const spriteImgs = {
cryodon: loadImage("assets/cryodon.png"),
raptoe: loadImage("assets/raptoe.png"),
razor: loadImage("assets/razorclaw.png"),
spike: loadImage("assets/spikejaw.png"),
};

function loadImage(src){
const img = new Image();
img.src = src;
return img;
}

function getSpriteCrop(img){
// Works for your “sheet” images: take a crop around the first creature.
// If the file isn't present, we’ll fallback to placeholder.
if(!img || !img.complete || img.naturalWidth===0) return null;

const w = img.naturalWidth, h = img.naturalHeight;
// Heuristic crop: ignore top banner area.
const y0 = Math.floor(h * 0.18);
const x0 = Math.floor(w * 0.02);
const cw = Math.floor(w * 0.23);
const ch = Math.floor(h * 0.26);
return { x:x0, y:y0, w:cw, h:ch };
}

// ===== Collectibles (ice shards instead of “teeth”) =====
const shards = [];
function placeShards(){
shards.length = 0;
// 1 in forest, 2 in ice biome (to force visiting it)
const targets = [
{ region:"forest" },
{ region:"ice" },
{ region:"ice" }
];
for(const t of targets){
let placed = false;
for(let tries=0; tries<500 && !placed; tries++){
let x, y;
if(t.region==="ice"){
x = Math.floor(44 + rand()*16);
y = Math.floor(12 + rand()*40);
} else {
x = Math.floor(3 + rand()*34);
y = Math.floor(18 + rand()*40);
}
if(map[idx(x,y)]===0){
// not too close to player start
const dx = (x+0.5)-player.x, dy = (y+0.5)-player.y;
if(dx*dx+dy*dy < 80) continue;
shards.push({ x:x+0.5, y:y+0.5, taken:false, glow:rand()*10 });
placed = true;
}
}
}
}
placeShards();

// ===== Enemies =====
// Raptoe pack (3), Razorclaw (1), Spikejaw (1)
// Spawn FAR from player to match your request.
const enemies = [];
function spawnEnemies(){
enemies.length = 0;
function spawn(kind, speed, dmg, radius){
let placed=false;
for(let tries=0; tries<2000 && !placed; tries++){
const x = 5 + rand()*(W-10);
const y = 5 + rand()*(H-10);
if(map[idx(x|0,y|0)]!==0) continue;
const dx = x - player.x, dy = y - player.y;
const dist2 = dx*dx+dy*dy;
if(dist2 < 900) continue; // FAR spawn (>=30 tiles)
enemies.push({
kind,
x, y,
vx:0, vy:0,
speed,
dmg,
radius,
state:"hunt",
cool: 0,
screamT: 2 + rand()*3,
});
placed=true;
}
}
// 3 raptoes
for(let i=0;i<3;i++) spawn("raptoe", 1.55, 7, 0.35);
spawn("razor", 1.30, 13, 0.45);
spawn("spike", 1.10, 18, 0.50);
}
spawnEnemies();

// ===== Helpers =====
function tileAt(x,y){
const xi = Math.floor(x), yi = Math.floor(y);
if(!inb(xi, yi)) return 1;
return map[idx(xi, yi)];
}
function isBlocked(x,y){
const t = tileAt(x,y);
return (t === 1 || t === 2);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// ===== Raycast renderer =====
const RAYS = 420; // more = smoother
const MAXD = 30; // max ray distance
function castRay(rx, ry, ra){
// DDA
let mapX = Math.floor(rx), mapY = Math.floor(ry);

const sin = Math.sin(ra), cos = Math.cos(ra);
const deltaDistX = Math.abs(1 / (cos || 1e-6));
const deltaDistY = Math.abs(1 / (sin || 1e-6));

let stepX, stepY;
let sideDistX, sideDistY;

if(cos < 0){
stepX = -1;
sideDistX = (rx - mapX) * deltaDistX;
} else {
stepX = 1;
sideDistX = (mapX + 1.0 - rx) * deltaDistX;
}
if(sin < 0){
stepY = -1;
sideDistY = (ry - mapY) * deltaDistY;
} else {
stepY = 1;
sideDistY = (mapY + 1.0 - ry) * deltaDistY;
}

let hit = 0;
let side = 0;
let dist = 0;

while(dist < MAXD){
if(sideDistX < sideDistY){
sideDistX += deltaDistX;
mapX += stepX;
side = 0;
} else {
sideDistY += deltaDistY;
mapY += stepY;
side = 1;
}
if(!inb(mapX,mapY)){ hit = 1; break; }
const t = map[idx(mapX,mapY)];
if(t === 1 || t === 2){
hit = t;
// distance to the wall
dist = side===0 ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
break;
}
dist = Math.min(sideDistX, sideDistY);
}

return { hit, dist, side, mapX, mapY, cos, sin };
}

function draw(){
const w = canvas.width, h = canvas.height;

// Determine biome by position
const inIce = (player.x>=world.iceRect.x0 && player.x<=world.iceRect.x1 && player.y>=world.iceRect.y0 && player.y<=world.iceRect.y1);
player.biome = inIce ? "ice" : "forest";
elBiome.textContent = inIce ? "Ice" : "Forest";

// Sky / canopy (super big trees cover the sky)
ctx.clearRect(0,0,w,h);
const skyH = Math.floor(h * 0.42); // less sky visible = canopy vibe
// base sky
ctx.fillStyle = inIce ? "#0a1c2a" : "#06110b";
ctx.fillRect(0,0,w,skyH);

// canopy silhouettes
ctx.globalAlpha = 0.55;
for(let i=0;i<10;i++){
const x = (i/9)*w;
const y = skyH - 30 - (Math.sin(i*1.7)*18);
ctx.fillStyle = inIce ? "#061620" : "#031006";
ctx.beginPath();
ctx.ellipse(x, y, w*0.12, 70, 0, 0, Math.PI*2);
ctx.fill();
}
ctx.globalAlpha = 1;

// floor tint by biome
ctx.fillStyle = inIce ? "#0b2230" : "#051008";
ctx.fillRect(0, skyH, w, h-skyH);

// Fog overlay (thicker at distance)
const fogBase = inIce ? [190, 235, 255] : [20, 35, 25];

// Ray columns
const zBuffer = new Float32Array(RAYS);
for(let i=0;i<RAYS;i++){
const camX = (2*i / (RAYS-1) - 1);
const ra = player.a + camX * (player.fov/2);

const r = castRay(player.x, player.y, ra);
let dist = Math.max(0.001, r.dist * Math.cos(ra - player.a)); // fish-eye correction
zBuffer[i] = dist;

const colW = w / RAYS;
const wallH = Math.min(h, (h * 0.95) / dist);

const x = i * colW;
const y = (h/2) - wallH/2;

// Wall shading
const hit = r.hit;
if(hit === 1 || hit === 2){
const isIceWall = (hit === 2);
// base color
let base = isIceWall ? [160, 220, 255] : [70, 110, 70];
if(r.side===1){ base = base.map(v => v*0.78); } // side shade
// distance darken
const k = clamp(1 - dist / MAXD, 0, 1);
const c = base.map(v => Math.floor(v * (0.35 + 0.65*k)));

ctx.fillStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
ctx.fillRect(x, y, colW+1, wallH);

// bark/ice streak texture (simple)
ctx.globalAlpha = 0.18;
ctx.fillStyle = isIceWall ? "#ffffff" : "#0a0f0a";
for(let s=0;s<3;s++){
const tx = x + (colW*(s+1)/4);
ctx.fillRect(tx, y + (wallH*0.10*s), 1, wallH*0.9);
}
ctx.globalAlpha = 1;
}

// Fog per column
const fog = clamp(dist / MAXD, 0, 1);
const a = 0.70 * fog;
ctx.globalAlpha = a;
ctx.fillStyle = `rgb(${fogBase[0]},${fogBase[1]},${fogBase[2]})`;
ctx.fillRect(x, 0, colW+1, h);
ctx.globalAlpha = 1;
}

// Draw shards (as glowing ice shards)
for(const s of shards){
if(s.taken) continue;
drawBillboard(s.x, s.y, zBuffer, "shard");
}

// Draw cave marker (subtle glow so you can find it)
drawCaveGlow(zBuffer);

// Draw enemies (sorted far->near for proper overlap)
const sorted = enemies.slice().sort((a,b)=>{
const da=(a.x-player.x)**2+(a.y-player.y)**2;
const db=(b.x-player.x)**2+(b.y-player.y)**2;
return db-da;
});
for(const e of sorted){
drawBillboard(e.x, e.y, zBuffer, e.kind);
}

// Vignette + night grain
ctx.globalAlpha = 0.25;
ctx.fillStyle = "#000";
const g = ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.15, w/2,h/2, Math.min(w,h)*0.65);
g.addColorStop(0, "rgba(0,0,0,0)");
g.addColorStop(1, "rgba(0,0,0,0.95)");
ctx.fillStyle = g;
ctx.fillRect(0,0,w,h);
ctx.globalAlpha = 1;
}

function drawCaveGlow(zBuffer){
// Cave is tile type 3 at world.cave.x/y (open tile). We'll glow when in view.
const cx = world.cave.x + 0.5, cy = world.cave.y + 0.5;
drawBillboard(cx, cy, zBuffer, "cave");
}

function drawBillboard(sx, sy, zBuffer, kind){
const dx = sx - player.x;
const dy = sy - player.y;
const dist = Math.sqrt(dx*dx + dy*dy);
if(dist < 0.2 || dist > MAXD) return;

let ang = Math.atan2(dy, dx) - player.a;
// wrap angle
while(ang < -Math.PI) ang += Math.PI*2;
while(ang > Math.PI) ang -= Math.PI*2;

const halfFov = player.fov/2;
if(Math.abs(ang) > halfFov + 0.35) return;

const w = canvas.width, h = canvas.height;
const screenX = (0.5 + (ang / player.fov)) * w;

// size scale
let baseSize = (h * 0.72) / dist;
if(kind==="shard") baseSize *= 0.35;
if(kind==="cave") baseSize *= 0.85;
if(kind==="raptoe") baseSize *= 0.75;
if(kind==="razor") baseSize *= 0.95;
if(kind==="spike") baseSize *= 1.05;

const spriteW = baseSize;
const spriteH = baseSize;

const left = screenX - spriteW/2;
const top = (h/2) - spriteH/2 + (h*0.12/dist); // slight floor bias

// depth clip using zBuffer
const rayIndex = Math.floor((screenX / w) * (RAYS-1));
const z = zBuffer[clamp(rayIndex,0,RAYS-1)|0];
if(dist > z + 0.15) return;

// Draw
if(kind==="shard"){
// glowing ice shard
const t = performance.now()*0.001;
const pulse = 0.55 + 0.45*Math.sin(t*3.2 + sx*0.7 + sy*0.5);
ctx.globalAlpha = 0.75;
ctx.fillStyle = "rgba(140,235,255,0.85)";
ctx.beginPath();
ctx.moveTo(screenX, top);
ctx.lineTo(left + spriteW, top + spriteH*0.55);
ctx.lineTo(screenX, top + spriteH);
ctx.lineTo(left, top + spriteH*0.55);
ctx.closePath();
ctx.fill();
ctx.globalAlpha = 0.35 * pulse;
ctx.fillStyle = "rgba(255,255,255,0.9)";
ctx.beginPath();
ctx.moveTo(screenX, top + spriteH*0.10);
ctx.lineTo(left + spriteW*0.70, top + spriteH*0.55);
ctx.lineTo(screenX, top + spriteH*0.90);
ctx.lineTo(left + spriteW*0.30, top + spriteH*0.55);
ctx.closePath();
ctx.fill();
ctx.globalAlpha = 1;
return;
}

if(kind==="cave"){
// cave entrance marker (dark arch + faint glow)
ctx.globalAlpha = 0.85;
ctx.fillStyle = "rgba(0,0,0,0.55)";
ctx.beginPath();
ctx.ellipse(screenX, top + spriteH*0.62, spriteW*0.36, spriteH*0.40, 0, 0, Math.PI*2);
ctx.fill();
ctx.globalAlpha = 0.35;
ctx.strokeStyle = "rgba(160,200,255,0.45)";
ctx.lineWidth = Math.max(1, spriteW*0.02);
ctx.beginPath();
ctx.ellipse(screenX, top + spriteH*0.62, spriteW*0.38, spriteH*0.42, 0, 0, Math.PI*2);
ctx.stroke();
ctx.globalAlpha = 1;
return;
}

// Dino sprites
const img = (kind==="raptoe") ? spriteImgs.raptoe
: (kind==="razor") ? spriteImgs.razor
: (kind==="spike") ? spriteImgs.spike
: spriteImgs.cryodon;

const crop = getSpriteCrop(img);

if(!crop){
// placeholder silhouette
ctx.globalAlpha = 0.9;
ctx.fillStyle = "rgba(255,80,80,0.35)";
ctx.fillRect(left, top, spriteW, spriteH);
ctx.globalAlpha = 1;
return;
}

// Slight “realism”: shadow + color grading by biome
ctx.globalAlpha = 0.22;
ctx.fillStyle = "rgba(0,0,0,0.8)";
ctx.beginPath();
ctx.ellipse(screenX, top + spriteH*0.90, spriteW*0.35, spriteH*0.10, 0, 0, Math.PI*2);
ctx.fill();
ctx.globalAlpha = 1;

// draw crop into billboard
ctx.drawImage(img, crop.x, crop.y, crop.w, crop.h, left, top, spriteW, spriteH);

// biome tint + distance fade
const fog = clamp(dist / MAXD, 0, 1);
ctx.globalAlpha = 0.15 + 0.25*fog;
ctx.fillStyle = (player.biome==="ice") ? "rgba(160,220,255,0.25)" : "rgba(0,0,0,0.22)";
ctx.fillRect(left, top, spriteW, spriteH);
ctx.globalAlpha = 1;
}

// ===== Gameplay =====
let lastT = performance.now();
let stepTimer = 0;
let hintT = 0;
function setStatus(s){ elStatus.textContent = s; }

function update(dt){
if(!player.alive || player.won) return;

// mouse look
player.a += mouseDX * 0.0022;
mouseDX = 0;

// movement
const forward = (keys.has("w") ? 1 : 0) + (keys.has("s") ? -1 : 0);
const strafe = (keys.has("d") ? 1 : 0) + (keys.has("a") ? -1 : 0);

const wantSprint = keys.has("shift");
let speed = 2.1;
if(wantSprint && player.stam > 0.5) speed = 3.35;

// stamina
if(wantSprint && (forward!==0 || strafe!==0)){
player.stam -= 22 * dt;
} else {
player.stam += 14 * dt;
}
player.stam = clamp(player.stam, 0, 100);

const cos = Math.cos(player.a), sin = Math.sin(player.a);
let vx = (cos*forward + -sin*strafe) * speed;
let vy = (sin*forward + cos*strafe) * speed;

// normalize diagonal
const mag = Math.hypot(vx,vy);
if(mag > speed) { vx = vx/mag*speed; vy = vy/mag*speed; }

// collide
const nx = player.x + vx*dt;
const ny = player.y + vy*dt;

const pad = 0.20;
if(!isBlocked(nx+pad, player.y) && !isBlocked(nx-pad, player.y)) player.x = nx;
if(!isBlocked(player.x, ny+pad) && !isBlocked(player.x, ny-pad)) player.y = ny;

// footsteps
if(mag > 0.1){
stepTimer += dt * (wantSprint ? 2.2 : 1.6);
if(stepTimer > 0.65){
stepTimer = 0;
footstep();
}
} else {
stepTimer = Math.max(0, stepTimer - dt);
}

// shards pickup
for(const s of shards){
if(s.taken) continue;
const dx = s.x - player.x, dy = s.y - player.y;
if(dx*dx + dy*dy < 0.55*0.55){
s.taken = true;
player.shards++;
elShards.textContent = player.shards;
pickupSound();
hintT = 1.25;
setStatus(`Picked up an ice shard (${player.shards}/3).`);
}
}

// cave interaction
if(keys.has("e")){
const cx = world.cave.x + 0.5, cy = world.cave.y + 0.5;
const dx = cx - player.x, dy = cy - player.y;
const nearCave = (dx*dx + dy*dy) < 1.6*1.6;
if(nearCave){
if(player.shards >= 3){
player.won = true;
winSound();
setStatus("ESCAPED. You survived the night.");
showEndScreen(true);
} else {
setStatus("The cave won’t open. You need 3 ice shards.");
}
}
}

// enemies update
for(const e of enemies){
e.cool = Math.max(0, e.cool - dt);
e.screamT -= dt;

// occasional screech (spooky)
if(e.screamT <= 0){
if(dist2(e, player) < 20*20){
if(e.kind==="raptoe") screech("raptoe");
if(e.kind==="razor") screech("razor");
if(e.kind==="spike") screech("spike");
}
e.screamT = 3 + rand()*4;
}

// simple chase with line-ish behavior
const tx = player.x, ty = player.y;
const ddx = tx - e.x, ddy = ty - e.y;
const d = Math.hypot(ddx, ddy) || 1;

// pack behavior: raptoes try to offset angle a bit
let ax = ddx/d, ay = ddy/d;
if(e.kind==="raptoe"){
const swirl = (Math.sin((e.x+e.y)*1.7) * 0.35);
const rx = ax*Math.cos(swirl) - ay*Math.sin(swirl);
const ry = ax*Math.sin(swirl) + ay*Math.cos(swirl);
ax = rx; ay = ry;
}

// move with collision
const sp = e.speed;
const ex = e.x + ax * sp * dt;
const ey = e.y + ay * sp * dt;
if(!isBlocked(ex, e.y)) e.x = ex;
if(!isBlocked(e.x, ey)) e.y = ey;

// attack if close
const attackRange = 0.75 + e.radius;
if(dist2(e, player) < attackRange*attackRange && e.cool<=0){
e.cool = (e.kind==="raptoe") ? 0.85 : 1.15;
player.hp -= e.dmg;
hurtSound();
setStatus(`${nameOf(e.kind)} HIT YOU!`);
// knockback
const kx = (player.x - e.x) / (d||1);
const ky = (player.y - e.y) / (d||1);
const bx = player.x + kx*0.35;
const by = player.y + ky*0.35;
if(!isBlocked(bx, player.y)) player.x = bx;
if(!isBlocked(player.x, by)) player.y = by;

if(player.hp <= 0){
player.hp = 0;
player.alive = false;
loseSound();
setStatus("You were hunted.");
showEndScreen(false);
}
}
}

// UI bars
elStam.style.width = `${player.stam}%`;
elHp.style.width = `${player.hp}%`;

// hint fade
if(hintT > 0){
hintT -= dt;
elHint.style.opacity = String(clamp(hintT/1.25, 0, 1));
} else {
elHint.style.opacity = "0";
}
}

function dist2(a,b){
const dx = a.x - b.x, dy = a.y - b.y;
return dx*dx + dy*dy;
}
function nameOf(k){
if(k==="raptoe") return "RAPTOE";
if(k==="razor") return "RAZORCLAW";
if(k==="spike") return "SPIKEJAW";
return "???";
}

function showEndScreen(win){
overlay.style.display = "flex";
overlay.querySelector(".big").textContent = win ? "YOU ESCAPED." : "YOU WERE HUNTED.";
overlay.querySelector(".small").innerHTML = win
? `You collected the <b>3 ice shards</b> and reached the <b>cave</b>.<br>Press Start to play again.`
: `The night won.<br>Press Start to try again.`;
}

function resetGame(){
player.x = 10.5; player.y = 56.5;
player.a = -Math.PI/2;
player.hp = 100; player.stam = 100;
player.shards = 0;
player.alive = true;
player.won = false;
elShards.textContent = "0";
setStatus("Find 3 ice shards and escape.");
placeShards();
spawnEnemies();
}

// ===== Loop =====
function loop(t){
const dt = Math.min(0.05, (t - lastT) / 1000);
lastT = t;
update(dt);
draw();
requestAnimationFrame(loop);
}

// ===== Start =====
startBtn.onclick = async () => {
overlay.style.display = "none";
if(!AC) audioInit();
try { await AC.resume(); } catch {}
resetGame();
setStatus("Survive. They spawned far… for now.");
// encourage pointer lock
setTimeout(()=> {
if(!pointerLocked) setStatus("Click the game to lock mouse (first person).");
}, 600);
};

// Start render loop immediately
requestAnimationFrame((t)=>{ lastT=t; loop(t); });
})();
</script>
</body>
</html>
